__device__ void ring2pixs(int ringstart, int npixs, int* pixs) {
    for (int i = 0; i < npixs; i++) {
        pixs[i] = ringstart + i;
    }
}

__device__ void getelements(double* arr, int* indices, const int size_indices, double* result){
    for (int i = 0; i < size_indices; i++) {
        result[i] = arr[indices[i]];
    }
}


__global__ void compute_pointing_alt1(KernelParams *kp, KernelLocals_lp kl, double *pointings) {
    //idx is nring
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    double PI = 3.14159265359;
    

    if (idx <= kp->nring) {
        const int ringstart = kp->ringstarts[idx];
        const int npixring = kp->nphis[idx];
        int triquand = round(cos(kp->thetalocs[idx]));

        for (int i = ringstart; i < ringstart+npixring; i++) {
            kl.philocs[i] = fmod(kp->phi0[idx] + i * (2. * PI / npixring), 2.*PI);
        }
        //TODO implement this for correct offset
        // phis = phis//[pixs - self.geom.ofs[ir]]

        dev_norm(kp->red, kp->imd, ringstart, ringstart+npixring, kl.d);

        if (dev_isbigger(kl.d, ringstart, ringstart+npixring, 0.001)){
            dev_besselj0(kl.d, ringstart, ringstart+npixring, kl.sind_d);
        } else {
            sindod_m1(kl.d, ringstart, ringstart+npixring, kl.sind_d);
        }
        if (triquand == 0){ // #---'close' to equator, where cost ~ 0 
            for (int i = ringstart; i < ringstart+npixring; i++) {
                kl.dphi[i] = asin(kp->imd[i] / sqrt(1. - cos(kp->thetalocs[idx])*cos(kp->thetalocs[idx])) * kl.sind_d[i]);
                kl.thtp[i] = acos(cos(kp->thetalocs[idx]) * cos(sqrt(kl.d[i])) - kp->red[i] * kl.sind_d[i] * sqrt(1. - cos(kp->thetalocs[idx])*cos(kp->thetalocs[idx])));
            }
        } else {
            int isnorth = triquand == 1 ? 1 : 0;
            if (isnorth == 1){
                for (int i = ringstart; i < ringstart+npixring; i++) {
                    kl.e_t[i] = 2. * sin(kp->thetalocs[idx] * 0.5)*sin(kp->thetalocs[idx] * 0.5);
                }
            } else {
                for (int i = ringstart; i < ringstart+npixring; i++) {
                    kl.e_t[i] = 2. * cos(kp->thetalocs[idx] * 0.5)*cos(kp->thetalocs[idx] * 0.5);
                }
            }
            for (int i = ringstart; i < ringstart+npixring; i++) {
                kl.e_d[i] = 2. * sin(sqrt(kl.d[i]) * 0.5)*sin(sqrt(kl.d[i]) * 0.5);
                kl.e_tp[i] = kl.e_t[i] + kl.e_d[i] - kl.e_t[i] * kl.e_d[i] + (double)triquand * kp->red[i] * kl.sind_d[i] * sin(kp->thetalocs[idx]);
                kl.thtp[i] = asin(sqrt(max(kl.e_tp[i] * (2. - kl.e_tp[i]), 0.)));
            }
            if (isnorth == 1){
                for (int i = ringstart; i < ringstart+npixring; i++) {
                    kl.dphi[i] = atan2(kp->imd[i] * kl.sind_d[i], (1. - kl.e_d[i]) * sin(kp->thetalocs[idx]) + kp->red[i] * kl.sind_d[i] * (1. - kl.e_t[i])); // TODO possible x/y confusion
                }
            } else {
                for (int i = ringstart; i < ringstart+npixring; i++) {
                    kl.thtp[i] = PI - kl.thtp[i];
                    kl.dphi[i] = atan2(kp->imd[i] * kl.sind_d[i], (1. - kl.e_d[i]) * sin(kp->thetalocs[idx]) + kp->red[i] * kl.sind_d[i] * (kl.e_t[i] - 1.)); // TODO possible x/y confusion
                }
            }
        }
        for (int i = ringstart; i < ringstart+npixring; i++) {
            kl.dphi[i] = fmod(kl.philocs[i] + kl.dphi[i], 2. * PI);
        }
        for (int i = ringstart; i < ringstart+npixring; i++) {
            pointings[i] = kl.thtp[i];
            pointings[i + kp->npix] = kl.dphi[i];
            // TODO implement this (rotation of the polarization angle)
            // cot = np.cos(self.geom.theta[ir]) / np.sin(self.geom.theta[ir])
            // d = np.sqrt(t_red ** 2 + i_imd ** 2)
            // thp_phip_gamma[2, sli] = np.arctan2(i_imd, t_red ) - np.arctan2(i_imd, d * np.sin(d) * cot + t_red * np.cos(d))
        }
    }
}



void CUpointing_alt1(float* thetas_, float* phi0_, int* nphis, int* ringstarts, double *red, double *imd, int nring, int npix, double *host_result) {
    printf("CUpointing_alt1:: starting allocation\n");
    double *thetas = (double*)malloc(nring * sizeof(double));
    double *phi0 = (double*)malloc(nring * sizeof(double));
    CUfloat_to_double(phi0_, phi0, nring);
    CUfloat_to_double(thetas_, thetas, nring);

    KernelParams *params;
    double *device_thetalocs, *device_phi0, *device_red, *device_imd;
    int *device_nphis, *device_ringstarts;
    cudaMalloc((void**)&device_thetalocs, nring * sizeof(double));
    cudaMalloc((void**)&device_phi0, nring * sizeof(double));
    cudaMalloc((void**)&device_nphis, nring * sizeof(int));
    cudaMalloc((void**)&device_ringstarts, nring * sizeof(int));
    cudaMalloc((void**)&device_red, npix * sizeof(double));
    cudaMalloc((void**)&device_imd, npix * sizeof(double));

    cudaMemcpy(device_thetalocs, thetas, nring * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(device_phi0, phi0, nring * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(device_nphis, nphis, nring * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(device_ringstarts, ringstarts, nring * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(device_red, red, npix * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(device_imd, imd, npix * sizeof(double), cudaMemcpyHostToDevice);
    //cudaMemcpy(device_philocs, imd, npix * sizeof(double), cudaMemcpyHostToDevice); // dummy values, correct values will be set in the kernel
    
    params->thetalocs = device_thetalocs;
    params->phi0 = device_phi0;
    params->nphis = device_nphis;
    params->ringstarts = device_ringstarts;
    params->red = device_red;
    params->imd = device_imd;
    params->nring = nring;
    params->npix = npix;


    KernelLocals_lp locals;
    double *device_sind_d, *device_dphi, *device_thtp, *device_e_d, *device_e_t, *device_e_tp, *device_d, *device_philocs;

    cudaMalloc((void**)&device_sind_d, npix * sizeof(double));
    cudaMalloc((void**)&device_dphi, npix * sizeof(double));
    cudaMalloc((void**)&device_thtp, npix * sizeof(double));
    cudaMalloc((void**)&device_e_d, npix * sizeof(double));
    cudaMalloc((void**)&device_e_t, npix * sizeof(double));
    cudaMalloc((void**)&device_e_tp, npix * sizeof(double));
    cudaMalloc((void**)&device_d, npix * sizeof(double));
    cudaMalloc((void**)&device_philocs, npix * sizeof(double));

    locals.sind_d = device_sind_d;
    locals.dphi = device_dphi;
    locals.thtp = device_thtp;
    locals.e_d = device_e_d;
    locals.e_t = device_e_t;
    locals.e_tp = device_e_tp;
    locals.d = device_d;
    locals.philocs = device_philocs;

    double *device_result;
    cudaMalloc((void**)&device_result, 2*npix * sizeof(double));

    const int threadsPerBlock = 256;
    int blocksPerGrid = (nring + threadsPerBlock - 1) / threadsPerBlock;
    printf("Calling kernel\n ");
    compute_pointing_alt1<<<blocksPerGrid, threadsPerBlock>>>(params, locals, device_result);
    cudaDeviceSynchronize();
    printf("Done with kernel\n ");
    cudaMemcpy(host_result, device_result, 2*npix * sizeof(double), cudaMemcpyDeviceToHost);
    printf("Done grabbing\n ");

    cudaFree(device_thetalocs);
    cudaFree(device_phi0);
    cudaFree(device_nphis);
    cudaFree(device_ringstarts);
    cudaFree(device_red);
    cudaFree(device_imd);
    cudaFree(device_sind_d);
    cudaFree(device_dphi);
    cudaFree(device_thtp);
    cudaFree(device_e_d);
    cudaFree(device_e_t);
    cudaFree(device_e_tp);
    cudaFree(device_d);
    free(thetas);
    free(phi0);
}



double* CUpointing_gpuarray(float* thetas_, float* phi0_, int* nphis, int* ringstarts, int device_red_ptr, int c, int nring, int npix, double *device_result, double *host_result) {
    printf("CUpointing_gpuarray:: starting allocation\n");
    clock_t start, stop;
    double cpu_time_used;
    start = clock();

    double *thetas = (double*)malloc(nring * sizeof(double));
    double *phi0 = (double*)malloc(nring * sizeof(double));
    CUfloat_to_double(phi0_, phi0, nring);
    CUfloat_to_double(thetas_, thetas, nring);

    KernelParams* params;
    double *device_thetalocs, *device_phi0, *device_philocs;
    int *device_nphis, *device_ringstarts;
    cudaMalloc((void**)&device_thetalocs, nring * sizeof(double));
    cudaMalloc((void**)&device_phi0, nring * sizeof(double));
    cudaMalloc((void**)&device_nphis, nring * sizeof(int));
    cudaMalloc((void**)&device_ringstarts, nring * sizeof(int));
    cudaMalloc((void**)&device_philocs, npix * sizeof(double));

    cudaMemcpy(device_thetalocs, thetas, nring * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(device_phi0, phi0, nring * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(device_nphis, nphis, nring * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(device_ringstarts, ringstarts, nring * sizeof(int), cudaMemcpyHostToDevice);
    //cudaMemcpy(device_philocs, imd, npix * sizeof(double), cudaMemcpyHostToDevice); // dummy values, correct values will be set in the kernel
    
    params->thetalocs = device_thetalocs;
    params->phi0 = device_phi0;
    params->nphis = device_nphis;
    params->ringstarts = device_ringstarts;
    params->red = reinterpret_cast<double*>(device_red_ptr);
    params->imd = reinterpret_cast<double*>(device_red_ptr);
    params->nring = nring;
    params->npix = npix;


    KernelLocals locals;
    double *dev_sint;
    double *dev_cost;
    double *dev_phi;
    double *dev_sind_d, *dev_a, *dev_d;
    double *dev_cos_a, *dev_twohav_aod;
    double *dev_e_a1, *dev_e_a2, *dev_e_a3;
    double *dev_np1, *dev_np2, *dev_np3;
    double *dev_npt, *dev_npp;
    double* dev_philocs;

    cudaMalloc((void**)&dev_phi, npix * sizeof(double));
    cudaMalloc((void**)&dev_sind_d, npix * sizeof(double));
    cudaMalloc((void**)&dev_a, npix * sizeof(double));
    cudaMalloc((void**)&dev_d, npix * sizeof(double));
    cudaMalloc((void**)&dev_cos_a, npix * sizeof(double));
    cudaMalloc((void**)&dev_twohav_aod, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a1, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a2, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a3, npix * sizeof(double));
    cudaMalloc((void**)&dev_np1, npix * sizeof(double));
    cudaMalloc((void**)&dev_np2, npix * sizeof(double));
    cudaMalloc((void**)&dev_np3, npix * sizeof(double));
    cudaMalloc((void**)&dev_npt, npix * sizeof(double));
    cudaMalloc((void**)&dev_npp, npix * sizeof(double));
    cudaMalloc((void**)&dev_philocs, npix * sizeof(double));

    locals.phi = dev_phi;
    locals.sind_d = dev_sind_d;
    locals.a = dev_a;
    locals.d = dev_d;
    locals.cos_a = dev_cos_a;
    locals.twohav_aod = dev_twohav_aod;
    locals.e_a1 = dev_e_a1;
    locals.e_a2 = dev_e_a2;
    locals.e_a3 = dev_e_a3;
    locals.np1 = dev_np1;
    locals.np2 = dev_np2;
    locals.np3 = dev_np3;
    locals.npt = dev_npt;
    locals.npp = dev_npp;
    locals.philocs = dev_philocs;
    
    cudaMalloc((void**)&device_result, 2*npix * sizeof(double));

    const int threadsPerBlock = 128;
    int blocksPerGrid = (nring + threadsPerBlock - 1) / threadsPerBlock;
    stop = clock();
    printf("Allocation done: duration = %f\n", (double)(stop - start)/CLOCKS_PER_SEC);
    printf("Calling kernel\n ");

    start = clock();
    // compute_pointing<<<blocksPerGrid, threadsPerBlock>>>(params, locals, device_result);
    cudaDeviceSynchronize();
    stop = clock();
    printf("Done with kernel: duration = %f\n", (double)(stop - start)/CLOCKS_PER_SEC);

    start = clock();
    cudaMemcpy(host_result, device_result, 2*npix * sizeof(double), cudaMemcpyDeviceToHost);
    stop = clock();
    printf("Done copying from GPU: duration = %f\n", (double)(stop - start)/CLOCKS_PER_SEC);

    // cudaError_t errSync  = cudaGetLastError();
    // cudaError_t errAsync = cudaDeviceSynchronize();
    // if (errSync != cudaSuccess) 
    // printf("Sync kernel error: %s\n", cudaGetErrorString(errSync));
    // if (errAsync != cudaSuccess)
    // printf("Async kernel error: %s\n", cudaGetErrorString(errAsync));

    //     printf("\npointing theta: ");
    //     for (int i = npix-1000; i < npix; i+=1) {
    //         printf("%.2f ", host_result[i]);
    //     }printf("\npointing phi: ");
    //    for (int i = 2*npix-1000; i < 2*npix; i+=1) {
    //         printf("%.2f ", host_result[i]);
    //     }printf("\n");

    cudaFree(dev_a);
    cudaFree(dev_cos_a);
    cudaFree(dev_cost);
    cudaFree(dev_d);
    cudaFree(dev_e_a1);
    cudaFree(dev_e_a2);
    cudaFree(dev_e_a3);
    cudaFree(dev_npp);
    cudaFree(dev_np1);
    cudaFree(dev_np2);
    cudaFree(dev_np3);
    cudaFree(dev_phi);
    cudaFree(dev_sind_d);
    cudaFree(dev_sint);
    cudaFree(dev_twohav_aod);
    cudaFree(device_thetalocs);
    cudaFree(device_phi0);
    cudaFree(device_nphis);
    cudaFree(device_ringstarts);
    // cudaFree(device_red);
    // cudaFree(device_imd);
    free(thetas);
    free(phi0);
    double* result = (double*)malloc(2*npix * sizeof(double));
    return result;
}


void CUpointing(float* thetas_, float* phi0_, int* nphis, int* ringstarts, double *red, double *imd, int nring, int npix, double *host_result) {
    printf("CUpointing:: starting allocation\n");
    clock_t start, stop;
    double cpu_time_used;
    start = clock();

    double *thetas = (double*)malloc(nring * sizeof(double));
    double *phi0 = (double*)malloc(nring * sizeof(double));
    CUfloat_to_double(phi0_, phi0, nring);
    CUfloat_to_double(thetas_, thetas, nring);

    KernelParams *params;
    double *device_thetalocs, *device_phi0, *device_red, *device_imd;
    int *device_nphis, *device_ringstarts;
    cudaMalloc((void**)&device_thetalocs, nring * sizeof(double));
    cudaMalloc((void**)&device_phi0, nring * sizeof(double));
    cudaMalloc((void**)&device_nphis, nring * sizeof(int));
    cudaMalloc((void**)&device_ringstarts, nring * sizeof(int));
    cudaMalloc((void**)&device_red, npix * sizeof(double));
    cudaMalloc((void**)&device_imd, npix * sizeof(double));
    

    cudaMemcpy(device_thetalocs, thetas, nring * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(device_phi0, phi0, nring * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(device_nphis, nphis, nring * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(device_ringstarts, ringstarts, nring * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(device_red, red, npix * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(device_imd, imd, npix * sizeof(double), cudaMemcpyHostToDevice);
    //cudaMemcpy(device_philocs, imd, npix * sizeof(double), cudaMemcpyHostToDevice); // dummy values, correct values will be set in the kernel
    
    params->thetalocs = device_thetalocs;
    params->phi0 = device_phi0;
    params->nphis = device_nphis;
    params->ringstarts = device_ringstarts;
    params->red = device_red;
    params->imd = device_imd;
    params->nring = nring;
    params->npix = npix;


    KernelLocals locals;
    double *dev_sint;
    double *dev_cost;
    double *dev_phi;
    double *dev_sind_d, *dev_a, *dev_d;
    double *dev_cos_a, *dev_twohav_aod;
    double *dev_e_a1, *dev_e_a2, *dev_e_a3;
    double *dev_np1, *dev_np2, *dev_np3;
    double *dev_npt, *dev_npp;
    double* dev_philocs;

    cudaMalloc((void**)&dev_phi, npix * sizeof(double));
    cudaMalloc((void**)&dev_sind_d, npix * sizeof(double));
    cudaMalloc((void**)&dev_a, npix * sizeof(double));
    cudaMalloc((void**)&dev_d, npix * sizeof(double));
    cudaMalloc((void**)&dev_cos_a, npix * sizeof(double));
    cudaMalloc((void**)&dev_twohav_aod, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a1, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a2, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a3, npix * sizeof(double));
    cudaMalloc((void**)&dev_np1, npix * sizeof(double));
    cudaMalloc((void**)&dev_np2, npix * sizeof(double));
    cudaMalloc((void**)&dev_np3, npix * sizeof(double));
    cudaMalloc((void**)&dev_npt, npix * sizeof(double));
    cudaMalloc((void**)&dev_npp, npix * sizeof(double));
    cudaMalloc((void**)&dev_philocs, npix * sizeof(double));
    

    locals.phi = dev_phi;
    locals.sind_d = dev_sind_d;
    locals.a = dev_a;
    locals.d = dev_d;
    locals.cos_a = dev_cos_a;
    locals.twohav_aod = dev_twohav_aod;
    locals.e_a1 = dev_e_a1;
    locals.e_a2 = dev_e_a2;
    locals.e_a3 = dev_e_a3;
    locals.np1 = dev_np1;
    locals.np2 = dev_np2;
    locals.np3 = dev_np3;
    locals.npt = dev_npt;
    locals.npp = dev_npp;
    locals.philocs = dev_philocs;
    
    double *device_result;
    cudaMalloc((void**)&device_result, 2*npix * sizeof(double));

    const int threadsPerBlock = 128;
    int blocksPerGrid = (nring + threadsPerBlock - 1) / threadsPerBlock;
    stop = clock();
    printf("Allocation done: duration = %f\n ", (double)(stop - start)/CLOCKS_PER_SEC);
    printf("Calling kernel\n ");

    start = clock();
    // compute_pointing<<<blocksPerGrid, threadsPerBlock>>>(params, locals, device_result);
    cudaDeviceSynchronize();
    stop = clock();
    printf("Done with kernel: duration = %f\n ", (double)(stop - start)/CLOCKS_PER_SEC);

    start = clock();
    cudaMemcpy(host_result, device_result, 2*npix * sizeof(double), cudaMemcpyDeviceToHost);
    stop = clock();
    printf("Done grabbing: duration = %f\n ", (double)(stop - start)/CLOCKS_PER_SEC);

    // cudaError_t errSync  = cudaGetLastError();
    // cudaError_t errAsync = cudaDeviceSynchronize();
    // if (errSync != cudaSuccess) 
    // printf("Sync kernel error: %s\n", cudaGetErrorString(errSync));
    // if (errAsync != cudaSuccess)
    // printf("Async kernel error: %s\n", cudaGetErrorString(errAsync));

//     printf("\npointing theta: ");
//     for (int i = npix-1000; i < npix; i+=1) {
//         printf("%.2f ", host_result[i]);
//     }printf("\npointing phi: ");
//    for (int i = 2*npix-1000; i < 2*npix; i+=1) {
//         printf("%.2f ", host_result[i]);
//     }printf("\n");

    cudaFree(dev_a);
    cudaFree(dev_cos_a);
    cudaFree(dev_cost);
    cudaFree(dev_d);
    cudaFree(dev_e_a1);
    cudaFree(dev_e_a2);
    cudaFree(dev_e_a3);
    cudaFree(dev_npp);
    cudaFree(dev_np1);
    cudaFree(dev_np2);
    cudaFree(dev_np3);
    cudaFree(dev_phi);
    cudaFree(dev_sind_d);
    cudaFree(dev_sint);
    cudaFree(dev_twohav_aod);
    cudaFree(device_thetalocs);
    cudaFree(device_phi0);
    cudaFree(device_nphis);
    cudaFree(device_ringstarts);
    cudaFree(device_red);
    cudaFree(device_imd);
    free(thetas);
    free(phi0);
}

int Cpointing_gpuarray(float* thetas_, float* phi0_, int* nphis, int* ringstarts, int red, int imd, int nring, int npix, double *host_result) {
    printf("pointing.cpp:: Cpointing_gpuarray\n");
    double *device_result = (double*)malloc(sizeof(double) * npix * 2);
    device_result = CUpointing_gpuarray(thetas_, phi0_, nphis, ringstarts, red, imd, nring, npix, device_result, host_result);
    int address = reinterpret_cast<uintptr_t>(device_result);
    return address;
}

    // m.def(
    //     "_Cpointing_MemcpyDeviceToHost",
    //     [](
    //         int device_memaddress,
    //         nb::ndarray<double>&host_result,
    //         int npix) {
    //         return Cpointing_MemcpyDeviceToHost(device_memaddress, host_result.data(), npix);
    //     }
    // );
    // m.def(
    //     "Cpointing_gpuarray",
    //     [](
    //         nb::ndarray<float>& thetas_,
    //         nb::ndarray<float>& phi0_,
    //         nb::ndarray<int>& nphis,
    //         nb::ndarray<int>& ringstarts,
    //         int device_red_ptr,
    //         int device_imd_ptr,
    //         int nring,
    //         int npix,
    //         nb::ndarray<double>&host_result) {
    //         return Cpointing_gpuarray(thetas_.data(), phi0_.data(), nphis.data(), ringstarts.data(), device_red_ptr, device_imd_ptr, nring, npix, host_result.data());
    //     }
    // );

    std::tuple<KernelParams*, double*> CUpointing_MemcpyHostToDevice(KernelParams *kp, int nring, int npix) {
    printf("CUpointing_MemcpyHostToDevice:: starting allocation\n");
    clock_t start, stop;
    double cpu_time_used;
    start = clock();

    double* dev_thetas;
    cudaMalloc((void**)&dev_thetas, nring * sizeof(double));
    cudaMemcpy(dev_thetas, kp.thetas, nring * sizeof(double), cudaMemcpyHostToDevice);
    double* dev_phi0;
    cudaMalloc((void**)&dev_phi0, nring * sizeof(double));
    cudaMemcpy(dev_phi0, kp.phi0, nring * sizeof(double), cudaMemcpyHostToDevice);
    int* dev_nphis;
    cudaMalloc((void**)&dev_nphis, nring * sizeof(int));
    cudaMemcpy(dev_nphis, kp.nphis, nring * sizeof(int), cudaMemcpyHostToDevice);
    int* dev_ringstarts;
    cudaMalloc((void**)&dev_ringstarts, nring * sizeof(int));
    cudaMemcpy(dev_ringstarts, kp.ringstarts, nring * sizeof(int), cudaMemcpyHostToDevice);
    KernelParams *deviceStruct;
    cudaMalloc((void**)&deviceStruct, sizeof(KernelParams));
    cudaMemcpy(deviceStruct, kp, sizeof(KernelParams), cudaMemcpyHostToDevice);

    double *device_result;
    cudaMalloc((void**)&device_result, 2*npix * sizeof(double));


    cudaError_t errSync  = cudaGetLastError();
    cudaError_t errAsync = cudaDeviceSynchronize();
    if (errSync != cudaSuccess) 
    printf("Sync kernel error: %s\n", cudaGetErrorString(errSync));
    if (errAsync != cudaSuccess)
    printf("Async kernel error: %s\n", cudaGetErrorString(errAsync));

    stop = clock();
    printf("deviceStruct: %p\n", deviceStruct);
    printf("device_result: %p\n", device_result);
    printf("Done with allocation: duration = %f\n", (double)(stop - start)/CLOCKS_PER_SEC);
    return std::make_tuple(deviceStruct, device_result);
}

double* CUpointing_exec_ptrs(int thetas_, int phi0_, int nphis, int ringstarts, int device_red_ptr, int device_imd_ptr, int nring, int npix, double* host_result) {
    printf("CUpointing_exec:: starting kernel\n");
    clock_t start, stop;
    double cpu_time_used;
    start = clock();

    KernelLocals kl;
    double *dev_sint;
    double *dev_cost;
    double *dev_phi;
    double *dev_sind_d, *dev_a, *dev_d;
    double *dev_cos_a, *dev_twohav_aod;
    double *dev_e_a1, *dev_e_a2, *dev_e_a3;
    double *dev_np1, *dev_np2, *dev_np3;
    double *dev_npt, *dev_npp;
    double* dev_philocs;

    cudaMalloc((void**)&dev_phi, npix * sizeof(double));
    cudaMalloc((void**)&dev_sind_d, npix * sizeof(double));
    cudaMalloc((void**)&dev_a, npix * sizeof(double));
    cudaMalloc((void**)&dev_d, npix * sizeof(double));
    cudaMalloc((void**)&dev_cos_a, npix * sizeof(double));
    cudaMalloc((void**)&dev_twohav_aod, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a1, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a2, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a3, npix * sizeof(double));
    cudaMalloc((void**)&dev_np1, npix * sizeof(double));
    cudaMalloc((void**)&dev_np2, npix * sizeof(double));
    cudaMalloc((void**)&dev_np3, npix * sizeof(double));
    cudaMalloc((void**)&dev_npt, npix * sizeof(double));
    cudaMalloc((void**)&dev_npp, npix * sizeof(double));
    cudaMalloc((void**)&dev_philocs, npix * sizeof(double));

    kl.phi = dev_phi;
    kl.sind_d = dev_sind_d;
    kl.a = dev_a;
    kl.d = dev_d;
    kl.cos_a = dev_cos_a;
    kl.twohav_aod = dev_twohav_aod;
    kl.e_a1 = dev_e_a1;
    kl.e_a2 = dev_e_a2;
    kl.e_a3 = dev_e_a3;
    kl.np1 = dev_np1;
    kl.np2 = dev_np2;
    kl.np3 = dev_np3;
    kl.npt = dev_npt;
    kl.npp = dev_npp;
    kl.philocs = dev_philocs;

    KernelParams kp;
    printf("thetas_: %p\n", thetas_);
    printf("phi0_: %p\n", phi0_);
    printf("nphis: %p\n", nphis);
    printf("ringstarts: %p\n", ringstarts);
    printf("device_red_ptr: %p\n", device_red_ptr);
    printf("device_imd_ptr: %p\n", device_imd_ptr);


    kp.thetas = reinterpret_cast<double*>(thetas_);
    kp.phi0 = reinterpret_cast<double*>(phi0_);
    kp.nphis = reinterpret_cast<int*>(nphis);
    kp.ringstarts = reinterpret_cast<int*>(ringstarts);
    kp.red = reinterpret_cast<double*>(device_red_ptr);
    kp.imd = reinterpret_cast<double*>(device_imd_ptr);
    kp.nring = nring;
    kp.npix = npix;

    printf("kp.thetas: %p\n", kp.thetas);
    printf("kp.phi0_: %p\n", kp.phi0);
    printf("kp.nphis: %p\n", kp.nphis);
    printf("kp.ringstarts: %p\n", kp.ringstarts);
    printf("kp.device_red_ptr: %p\n", kp.red);
    printf("kp.device_imd_ptr: %p\n", kp.imd);

    double *dev_result;
    cudaMalloc((void**)&dev_result, 2*npix * sizeof(double));

    const int threadsPerBlock = 128;
    int blocksPerGrid = (nring + threadsPerBlock - 1) / threadsPerBlock;
    compute_pointing<<<blocksPerGrid, threadsPerBlock>>>(kp, kl, dev_result);
    cudaDeviceSynchronize();

    cudaError_t errSync  = cudaGetLastError();
    cudaError_t errAsync = cudaDeviceSynchronize();
    if (errSync != cudaSuccess) 
    printf("Sync kernel error: %s\n", cudaGetErrorString(errSync));
    if (errAsync != cudaSuccess)
    printf("Async kernel error: %s\n", cudaGetErrorString(errAsync));
    stop = clock();
    printf("Done with kernel: duration = %f\n", (double)(stop - start)/CLOCKS_PER_SEC);

    start = clock();
    cudaMemcpy(host_result, dev_result, 2*npix * sizeof(double), cudaMemcpyDeviceToHost);
    stop = clock();
    printf("Done copying from GPU: duration = %f\n", (double)(stop - start)/CLOCKS_PER_SEC);
    printf("npix: %d\n", npix);
    // printf("\nHost_result: ");
    // for (int i = 0; i < npix; i+=66) {
    //     printf("%.2f, ", host_result[i]);
    // }
    return host_result;
}

int CUpointing_exec(KernelParams *device_struct, double* device_result, int nring, int npix) {
    printf("CUpointing_exec:: starting kernel\n");
    printf("deviceStruct: %p\n", device_struct);
    printf("device_result: %p\n", device_result);
    clock_t start, stop;
    double cpu_time_used;
    start = clock();

    KernelLocals kl;
    double *dev_sint;
    double *dev_cost;
    double *dev_phi;
    double *dev_sind_d, *dev_a, *dev_d;
    double *dev_cos_a, *dev_twohav_aod;
    double *dev_e_a1, *dev_e_a2, *dev_e_a3;
    double *dev_np1, *dev_np2, *dev_np3;
    double *dev_npt, *dev_npp;
    double* dev_philocs;

    cudaMalloc((void**)&dev_phi, npix * sizeof(double));
    cudaMalloc((void**)&dev_sind_d, npix * sizeof(double));
    cudaMalloc((void**)&dev_a, npix * sizeof(double));
    cudaMalloc((void**)&dev_d, npix * sizeof(double));
    cudaMalloc((void**)&dev_cos_a, npix * sizeof(double));
    cudaMalloc((void**)&dev_twohav_aod, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a1, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a2, npix * sizeof(double));
    cudaMalloc((void**)&dev_e_a3, npix * sizeof(double));
    cudaMalloc((void**)&dev_np1, npix * sizeof(double));
    cudaMalloc((void**)&dev_np2, npix * sizeof(double));
    cudaMalloc((void**)&dev_np3, npix * sizeof(double));
    cudaMalloc((void**)&dev_npt, npix * sizeof(double));
    cudaMalloc((void**)&dev_npp, npix * sizeof(double));
    cudaMalloc((void**)&dev_philocs, npix * sizeof(double));

    kl.phi = dev_phi;
    kl.sind_d = dev_sind_d;
    kl.a = dev_a;
    kl.d = dev_d;
    kl.cos_a = dev_cos_a;
    kl.twohav_aod = dev_twohav_aod;
    kl.e_a1 = dev_e_a1;
    kl.e_a2 = dev_e_a2;
    kl.e_a3 = dev_e_a3;
    kl.np1 = dev_np1;
    kl.np2 = dev_np2;
    kl.np3 = dev_np3;
    kl.npt = dev_npt;
    kl.npp = dev_npp;
    kl.philocs = dev_philocs;

    const int threadsPerBlock = 128;
    int blocksPerGrid = (nring + threadsPerBlock - 1) / threadsPerBlock;
    // compute_pointing<<<blocksPerGrid, threadsPerBlock>>>(device_struct, kl, device_result);
    cudaDeviceSynchronize();

    cudaError_t errSync  = cudaGetLastError();
    cudaError_t errAsync = cudaDeviceSynchronize();
    if (errSync != cudaSuccess) 
    printf("Sync kernel error: %s\n", cudaGetErrorString(errSync));
    if (errAsync != cudaSuccess)
    printf("Async kernel error: %s\n", cudaGetErrorString(errAsync));
    stop = clock();
    printf("Done with kernel: duration = %f\n", (double)(stop - start)/CLOCKS_PER_SEC);

    return cudaSuccess;
}

double* CUpointing_MemcpyDeviceToHost(double *device_result, double *host_result, int npix) {
    clock_t start, stop;
    double cpu_time_used;
    start = clock();
    cudaMemcpy(host_result, device_result, 2*npix * sizeof(double), cudaMemcpyDeviceToHost);
    stop = clock();
    printf("Done copying from GPU: duration = %f\n", (double)(stop - start)/CLOCKS_PER_SEC);

    // cudaError_t errSync  = cudaGetLastError();
    // cudaError_t errAsync = cudaDeviceSynchronize();
    // if (errSync != cudaSuccess) 
    // printf("Sync kernel error: %s\n", cudaGetErrorString(errSync));
    // if (errAsync != cudaSuccess)
    // printf("Async kernel error: %s\n", cudaGetErrorString(errAsync));

    printf("\nHost_result: ");
    for (int i = 0; i < npix; i+=66) {
        printf("%.2f, ", host_result[i]);
    }
    return host_result;
}

void dealloacte(double* dev_arr) {
    cudaFree(dev_arr);
}


std::tuple<KernelParams*, double*> _Cpointing_MemcpyHostToDevice(float* thetas_, float* phi0_, int* nphis, int* ringstarts, int device_red_ptr, int device_imd_ptr, int nring, int npix, KernelParams *kp, double* device_result) {
    printf("pointing.cpp:: Cpointing_MemcpyHostToDevice\n");
    
    kp->red = reinterpret_cast<double*>(device_red_ptr);
    kp->imd = reinterpret_cast<double*>(device_imd_ptr);
    kp->nring = nring;
    kp->npix = npix;
    double *thetas = (double*)malloc(nring * sizeof(double));
    double *phi0 = (double*)malloc(nring * sizeof(double));
    float_to_double(phi0_, phi0, nring);
    float_to_double(thetas_, thetas, nring);
    kp->thetas = thetas;
    kp->phi0 = phi0;
    kp->nphis = nphis;
    kp->ringstarts = ringstarts;
    // double* deviceStruct = (double*)malloc(2*npix * sizeof(double));
    auto devstruct_devres = CUpointing_MemcpyHostToDevice(kp, nring, npix);
    printf("deviceStruct: %p\n", std::get<0>(devstruct_devres));
    printf("device_result: %p\n", std::get<1>(devstruct_devres));
    int device_memaddress = reinterpret_cast<uintptr_t>(std::get<0>(devstruct_devres));
    return devstruct_devres;
}

int _Cpointing_exec(KernelParams *device_struct, double* device_result, int nring, int npix) {
    // Could return Kernel status here
    printf("pointing.cpp:: Cpointing_exec\n");
    return CUpointing_exec(device_struct, device_result, nring, npix);
}

double* _Cpointing_exec_ptrs(int thetas_, int phi0_, int nphis, int ringstarts, int device_red_ptr, int device_imd_ptr, int nring, int npix, double* host_result) {
    // Could return Kernel status here
    printf("pointing.cpp:: Cpointing_exec\n");
    return CUpointing_exec_ptrs(thetas_, phi0_, nphis, ringstarts, device_red_ptr, device_imd_ptr, nring, npix, host_result);
}

double* _Cpointing_MemcpyDeviceToHost(double* device_result, double *host_result, int npix) {
    // Return host_result here
    printf("pointing.cpp:: _Cpointing_MemcpyDeviceToHost\n");
    return CUpointing_MemcpyDeviceToHost(device_result, host_result, npix);
}

double* Cpointing_MemcpyDeviceToHost(int device_memaddress, double *host_result, int npix) {
    // Return host_result here
    printf("pointing.cpp:: Cpointing_MemcpyDeviceToHost\n");
    double *device_result = reinterpret_cast<double*>(device_memaddress);
    return CUpointing_MemcpyDeviceToHost(device_result, host_result, npix);
}

int Cpointing(float* thetas_, float* phi0_, int* nphis, int* ringstarts, int device_red_ptr, int device_imd_ptr, int nring, int npix, double *host_result, int transfer_type){
    KernelParams *kp = new KernelParams;
    double *device_result = (double*)malloc(2*npix * sizeof(double));
    // printf("\npointing.cpp:: Cpointing - before HtD\n");

    auto devstruct_devres = _Cpointing_MemcpyHostToDevice(thetas_, phi0_, nphis, ringstarts, device_red_ptr, device_imd_ptr, nring, npix, kp, device_result);
    printf("\npointing.cpp:: Cpointing - after HtD\n");
    printf("kp->nring: %d\n", kp->nring);
    printf("kp->npix: %d\n", kp->npix);
    printf("device_struct: %p\n", std::get<0>(devstruct_devres));
    printf("device_result: %p\n\n", std::get<1>(devstruct_devres));
    int status = _Cpointing_exec(std::get<0>(devstruct_devres), std::get<1>(devstruct_devres), nring, npix);
    printf("status: %d\n", status);
    if (transfer_type == 0){
        // For now I assume that red and imd is already on device, only all others need to be copied/allocated.
        // TODO add another transfer_type that allows to copy red and imd to gpu.
    }
    if (transfer_type == 1){
        _Cpointing_MemcpyDeviceToHost(std::get<1>(devstruct_devres), host_result, npix);
    }
    return reinterpret_cast<uintptr_t>(device_result); //this returns the device_memaddress,result goes to host_result
}