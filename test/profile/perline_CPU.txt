Timer unit: 1e-06 s

Total time: 6.26713 s
File: /mnt/home/sbelkner/git/pySHT/pysht/deflection/CPU_nufft_transformer.py
Function: _build_angles at line 130

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   130                                               @profile
   131                                               def _build_angles(self, dlm, lmax_dlm, mmax_dlm, fortran=True, calc_rotation=True):
   132                                                   """Builds deflected positions and angles
   133                                           
   134                                                       Returns (npix, 3) array with new tht, phi and -gamma
   135                                           
   136                                                   """
   137         1         13.5     13.5      0.0          fns = ['ptg'] + calc_rotation * ['gamma']
   138         1        230.8    230.8      0.0          if not np.all([self.cacher.is_cached(fn) for fn in fns]) :
   139         1    5177251.0    5e+06     82.6              d1 = self._build_d1(dlm, lmax_dlm, mmax_dlm)
   140                                                       # Probably want to keep red, imd double precision for the calc?
   141         1          7.3      7.3      0.0              if HAS_DUCCPOINTING:
   142         1         51.5     51.5      0.0                  tht, phi0, nph, ofs = self.geom.theta, self.geom.phi0, self.geom.nph, self.geom.ofs
   143                                                           # print("theta=", tht, "phi0=", phi0, "nphi=", nph, "ringstart=", ofs, "deflect=", d1.T, "calc_rotation=", calc_rotation, "nthreads=", self.nthreads)
   144         2     642519.9 321259.9     10.3                  tht_phip_gamma = get_deflected_angles(theta=tht, phi0=phi0, nphi=nph, ringstart=ofs, deflect=d1.T,
   145         1          0.6      0.6      0.0                                                          calc_rotation=calc_rotation, nthreads=self.nthreads)
   146         1          1.4      1.4      0.0                  if calc_rotation:
   147         1     308689.3 308689.3      4.9                      self.cacher.cache(fns[0], tht_phip_gamma[:, 0:2])
   148         1     138365.0 138365.0      2.2                      self.cacher.cache(fns[1], tht_phip_gamma[:, 2] if not self.single_prec else tht_phip_gamma[:, 2].astype(np.float32))
   149                                                           else:
   150                                                               self.cacher.cache(fns[0], tht_phip_gamma)
   151                                                           # print('build_angles')
   152         1          0.3      0.3      0.0                  return
   153                                                       npix = self.npix
   154                                                       if fortran and HAS_FORTRAN:
   155                                                           red, imd = d1
   156                                                           tht, phi0, nph, ofs = self.geom.theta, self.geom.phi0, self.geom.nph, self.geom.ofs
   157                                                           if self.single_prec_ptg:
   158                                                               thp_phip_gamma = fremap.fpointing(red, imd, tht, phi0, nph, ofs, self.nthreads)
   159                                                           else:
   160                                                               thp_phip_gamma = fremap.pointing(red, imd, tht, phi0, nph, ofs, self.nthreads)
   161                                                           # print('build angles <- th-phi-gm (ftn)')
   162                                                           # I think this just trivially turns the F-array into a C-contiguous array:
   163                                                           self.cacher.cache(fns[0], thp_phip_gamma.transpose()[:, 0:2])
   164                                                           if calc_rotation:
   165                                                               self.cacher.cache(fns[1], thp_phip_gamma.transpose()[:, 2] if not self.single_prec else thp_phip_gamma.transpose()[:, 2].astype(np.float32))
   166                                                           return
   167                                                       elif fortran and not HAS_FORTRAN:
   168                                                           print('Cant use fortran pointing building since import failed. Falling back on python impl.')
   169                                                       thp_phip_gamma = np.empty((3, npix), dtype=float)  # (-1) gamma in last arguement
   170                                                       startpix = 0
   171                                                       assert np.all(self.geom.theta > 0.) and np.all(self.geom.theta < np.pi), 'fix this (cotangent below)'
   172                                                       red, imd = d1
   173                                                       for ir in np.argsort(self.geom.ofs): # We must follow the ordering of scarf position-space map
   174                                                           pixs = Geom.rings2pix(self, [ir])
   175                                                           if pixs.size > 0:
   176                                                               t_red = red[pixs]
   177                                                               i_imd = imd[pixs]
   178                                                               phis = Geom.phis(self, ir)[pixs - self.geom.ofs[ir]]
   179                                                               assert phis.size == pixs.size, (phis.size, pixs.size)
   180                                                               thts = self.geom.theta[ir] * np.ones(pixs.size)
   181                                                               thtp_, phip_ = d2ang(t_red, i_imd, thts , phis, int(np.round(np.cos(self.geom.theta[ir]))))
   182                                                               sli = slice(startpix, startpix + len(pixs))
   183                                                               thp_phip_gamma[0, sli] = thtp_
   184                                                               thp_phip_gamma[1, sli] = phip_
   185                                                               cot = np.cos(self.geom.theta[ir]) / np.sin(self.geom.theta[ir])
   186                                                               d = np.sqrt(t_red ** 2 + i_imd ** 2)
   187                                                               thp_phip_gamma[2, sli] = np.arctan2(i_imd, t_red ) - np.arctan2(i_imd, d * np.sin(d) * cot + t_red * np.cos(d))
   188                                                               startpix += len(pixs)
   189                                                       self.cacher.cache(fns[0], thp_phip_gamma.T[:, 0:2])
   190                                                       if calc_rotation:
   191                                                           self.cacher.cache(fns[1], thp_phip_gamma.T[:, 2] if not self.single_prec else thp_phip_gamma.T[:, 2].astype(np.float32) )
   192                                                       assert startpix == npix, (startpix, npix)
   193                                                       return

Total time: 14.2658 s
File: /mnt/home/sbelkner/git/pySHT/pysht/deflection/CPU_nufft_transformer.py
Function: gclm2lenmap at line 233

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   233                                               @profile
   234                                               def gclm2lenmap(self, gclm, dlm, lmax, mmax, spin, nthreads, polrot=True):
   235                                                   """CPU algorithm for spin-n remapping using finufft
   236                                                       Args:
   237                                                           gclm: input alm array, shape (ncomp, nalm), where ncomp can be 1 (gradient-only) or 2 (gradient or curl)
   238                                                           mmax: mmax parameter of alm array layout, if different from lmax
   239                                                           spin: spin (>=0) of the transform
   240                                                           backwards: forward or backward (adjoint) operation
   241                                                   """ 
   242                                                       
   243         1         31.0     31.0      0.0          gclm = np.atleast_2d(gclm)
   244         1         28.2     28.2      0.0          lmax_unl = Alm.getlmax(gclm[0].size, mmax)
   245         1          0.5      0.5      0.0          if mmax is None:
   246                                                       mmax = lmax_unl
   247         1          1.0      1.0      0.0          if self.single_prec and gclm.dtype != np.complex64:
   248                                                       gclm = gclm.astype(np.complex64)
   249                                                       self.tim.add('type conversion')
   250                                           
   251                                                   # transform slm to Clenshaw-Curtis map
   252         1         10.8     10.8      0.0          ntheta = ducc0.fft.good_size(lmax_unl + 2)
   253         1          0.5      0.5      0.0          nphihalf = ducc0.fft.good_size(lmax_unl + 1)
   254         1          0.2      0.2      0.0          nphi = 2 * nphihalf
   255                                                   # Is this any different to scarf wraps ? NB: type of map, map_df, and FFTs will follow that of input gclm
   256         1         13.0     13.0      0.0          mode = ducc_sht_mode(gclm, spin)
   257         2    1882581.8 941290.9     13.2          map = ducc0.sht.experimental.synthesis_2d(alm=gclm, ntheta=ntheta, nphi=nphi,
   258         1          0.3      0.3      0.0                                  spin=spin, lmax=lmax_unl, mmax=mmax, geometry="CC", nthreads=nthreads, mode=mode)
   259                                                   # extend map to double Fourier sphere map
   260         1         41.6     41.6      0.0          map_dfs = np.empty((2 * ntheta - 2, nphi), dtype=np.complex128 if spin == 0 else ctype[map.dtype])
   261         1          0.3      0.3      0.0          if spin == 0:
   262         1     138185.4 138185.4      1.0              map_dfs[:ntheta, :] = map[0]
   263                                                   else:
   264                                                       map_dfs[:ntheta, :].real = map[0]
   265                                                       map_dfs[:ntheta, :].imag = map[1]
   266         1        935.9    935.9      0.0          del map
   267                                           
   268         1     120724.4 120724.4      0.8          map_dfs[ntheta:, :nphihalf] = map_dfs[ntheta - 2:0:-1, nphihalf:]
   269         1      54272.3  54272.3      0.4          map_dfs[ntheta:, nphihalf:] = map_dfs[ntheta - 2:0:-1, :nphihalf]
   270         1          3.2      3.2      0.0          if (spin % 2) != 0:
   271                                                       map_dfs[ntheta:, :] *= -1
   272                                           
   273                                                   # go to Fourier space
   274         1          0.3      0.3      0.0          if spin == 0:
   275         1         29.4     29.4      0.0              tmp = np.empty(map_dfs.shape, dtype=np.complex128)
   276         1    1067159.1    1e+06      7.5              map_dfs = ducc0.fft.c2c(map_dfs, axes=(0, 1), inorm=2, nthreads=nthreads, out=tmp)
   277         1          1.4      1.4      0.0              del tmp
   278                                                   else:
   279                                                       map_dfs = ducc0.fft.c2c(map_dfs, axes=(0, 1), inorm=2, nthreads=nthreads, out=map_dfs)
   280                                           
   281         1         10.7     10.7      0.0          if self.planned: # planned nufft
   282                                                       assert ptg is None
   283                                                       plan = self.make_plan(lmax_unl, spin)
   284                                                       values = plan.u2nu(grid=map_dfs, forward=False, verbosity=self.verbosity)
   285                                                       self.tim.add('planned u2nu')
   286                                                   else:
   287         1          1.8      1.8      0.0              ptg = None
   288         1          0.7      0.7      0.0              if ptg is None:
   289                                                           # FIXME stop passing synthesis function as _get_d1 needs it..
   290         1    6469185.2    6e+06     45.3                  ptg = self._get_ptg(dlm, mmax)
   291         1         46.4     46.4      0.0              self.tim.add('get ptg')
   292                                           
   293         1     353680.4 353680.4      2.5              map_shifted = np.fft.fftshift(map_dfs, axes=(0,1))
   294         1    3960827.0    4e+06     27.8              v_ = finufft.nufft2d2(x=ptg[:,1][::-1], y=ptg[:,0], f=map_shifted.T.astype(np.complex128))
   295                                                       # FIXME ntheta and nphi are not the same for SHTns and ducc, SHTns.constructor gives the right shapes here.
   296         1          3.4      3.4      0.0              if self.shttransformer_desc == 'sthns':
   297                                                           values = np.roll(np.real(v_).reshape(*self.geom.constructor.spat_shape).T, int(self.geom.nph[0]/2-1), axis=1)
   298                                                       else:
   299         1     123154.7 123154.7      0.9                  values = np.roll(np.real(v_).reshape(-1,self.geom.nph[0]), int(self.geom.nph[0]/2-1), axis=1)
   300         1         23.1     23.1      0.0              self.tim.add('u2nu')
   301                                           
   302         1          2.8      2.8      0.0          if polrot * spin:
   303                                                       if self._cis:
   304                                                           cis = self._get_cischi()
   305                                                           for i in range(polrot * abs(spin)):
   306                                                               values *= cis
   307                                                           self.tim.add('polrot (cis)')
   308                                                       else:
   309                                                           if HAS_DUCCROTATE:
   310                                                               lensing_rotate(values, self._get_gamma(), spin, nthreads)
   311                                                               self.tim.add('polrot (ducc)')
   312                                                           else:
   313                                                               func = fremap.apply_inplace if values.dtype == np.complex128 else fremap.apply_inplacef
   314                                                               func(values, self._get_gamma(), spin, nthreads)
   315                                                               self.tim.add('polrot (fortran)')
   316                                                   # Return real array of shape (2, npix) for spin > 0
   317         1      94834.4  94834.4      0.7          return values.real.flatten() if spin == 0 else values.view(rtype[values.dtype]).reshape((values.size, 2)).T
   318                                                   # np.atleast_2d(values.real.flatten())

  6.27 seconds - /mnt/home/sbelkner/git/pySHT/pysht/deflection/CPU_nufft_transformer.py:130 - _build_angles
 14.27 seconds - /mnt/home/sbelkner/git/pySHT/pysht/deflection/CPU_nufft_transformer.py:233 - gclm2lenmap
