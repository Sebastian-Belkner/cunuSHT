Timer unit: 1e-06 s

Total time: 0.84829 s
File: /mnt/home/sbelkner/git/cunusht/cunusht/deflection/GPU_nufft_transformer.py
Function: _build_angles at line 93

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    93                                               @profile
    94                                               def _build_angles(self, synth_spin1_map, lmax_dlm, mmax_dlm, fortran=True, calc_rotation=True):
    95                                                   """Builds deflected positions and angles
    96                                                       Returns (npix, 3) array with new tht, phi and -gamma
    97                                                   """
    98         1          6.9      6.9      0.0          fns = ['ptg'] + calc_rotation * ['gamma']
    99         1        106.1    106.1      0.0          if not np.all([self.cacher.is_cached(fn) for fn in fns]) :
   100                                                       # Probably want to keep red, imd double precision for the calc?
   101         1          1.9      1.9      0.0              if HAS_DUCCPOINTING:
   102                                                           # FIXME if shtns is used, we need to access SHTns info about geom.
   103         1         17.4     17.4      0.0                  tht, phi0, nph, ofs = self.geom.theta, self.geom.phi0, self.geom.nph, self.geom.ofs
   104         2     402413.6 201206.8     47.4                  tht_phip_gamma = get_deflected_angles(theta=tht, phi0=phi0, nphi=nph, ringstart=ofs, deflect=synth_spin1_map.T,
   105         1          0.4      0.4      0.0                                                          calc_rotation=calc_rotation, nthreads=self.nthreads)
   106         1          0.9      0.9      0.0                  if calc_rotation:
   107         1     308191.0 308191.0     36.3                      self.cacher.cache(fns[0], tht_phip_gamma[:, 0:2])
   108         1     137552.0 137552.0     16.2                      self.cacher.cache(fns[1], tht_phip_gamma[:, 2] if not self.single_prec else tht_phip_gamma[:, 2].astype(np.float32))
   109                                                           else:
   110                                                               self.cacher.cache(fns[0], tht_phip_gamma)
   111         1          0.3      0.3      0.0                  return
   112                                                       
   113                                                       npix = self.geom.npix()
   114                                                       thp_phip_gamma = np.empty((3, npix), dtype=float)  # (-1) gamma in last arguement
   115                                                       startpix = 0
   116                                                       assert np.all(self.geom.theta > 0.) and np.all(self.geom.theta < np.pi), 'fix this (cotangent below)'
   117                                                       red, imd = synth_spin1_map
   118                                                       for ir in np.argsort(self.geom.ofs): # We must follow the ordering of scarf position-space map
   119                                                           pixs = Geom.rings2pix(self.geom, [ir])
   120                                                           if pixs.size > 0:
   121                                                               t_red = red[pixs]
   122                                                               i_imd = imd[pixs]
   123                                                               phis = Geom.phis(self.geom, ir)[pixs - self.geom.ofs[ir]]
   124                                                               assert phis.size == pixs.size, (phis.size, pixs.size)
   125                                                               thts = self.geom.theta[ir] * np.ones(pixs.size)
   126                                                               thtp_, phip_ = d2ang(t_red, i_imd, thts , phis, int(np.round(np.cos(self.geom.theta[ir]))))
   127                                                               sli = slice(startpix, startpix + len(pixs))
   128                                                               thp_phip_gamma[0, sli] = thtp_
   129                                                               thp_phip_gamma[1, sli] = phip_
   130                                                               cot = np.cos(self.geom.theta[ir]) / np.sin(self.geom.theta[ir])
   131                                                               d = np.sqrt(t_red ** 2 + i_imd ** 2)
   132                                                               thp_phip_gamma[2, sli] = np.arctan2(i_imd, t_red ) - np.arctan2(i_imd, d * np.sin(d) * cot + t_red * np.cos(d))
   133                                                               startpix += len(pixs)
   134                                                       self.cacher.cache(fns[0], thp_phip_gamma.T[:, 0:2])
   135                                                       if calc_rotation:
   136                                                           self.cacher.cache(fns[1], thp_phip_gamma.T[:, 2] if not self.single_prec else thp_phip_gamma.T[:, 2].astype(np.float32) )
   137                                                       assert startpix == npix, (startpix, npix)
   138                                                       return

Total time: 18.9288 s
File: /mnt/home/sbelkner/git/cunusht/cunusht/deflection/GPU_nufft_transformer.py
Function: gclm2lenmap at line 191

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   191                                               @profile
   192                                               def gclm2lenmap(self, gclm, dlm, lmax, mmax, spin, nthreads, polrot=True):
   193                                                   """GPU algorithm for spin-n remapping using cufinufft
   194                                                       Args:
   195                                                           gclm: input alm array, shape (ncomp, nalm), where ncomp can be 1 (gradient-only) or 2 (gradient or curl)
   196                                                           mmax: mmax parameter of alm array layout, if different from lmax
   197                                                           spin: spin (>=0) of the transform
   198                                                           backwards: forward or backward (adjoint) operation
   199                                                   """ 
   200                                                       
   201                                                   ### SETUP ###
   202         1         30.2     30.2      0.0          gclm = np.atleast_2d(gclm)
   203         1         33.1     33.1      0.0          lmax_unl = Alm.getlmax(gclm[0].size, mmax)
   204         1          0.4      0.4      0.0          if mmax is None:
   205                                                       mmax = lmax_unl
   206         1          1.5      1.5      0.0          if self.single_prec and gclm.dtype != np.complex64:
   207                                                       gclm = gclm.astype(np.complex64)
   208                                                       self.tim.add('type conversion')
   209         1         21.2     21.2      0.0          print(' ------------ Finished setup -------------')
   210                                           
   211                                           
   212                                                   ### SOME PARAMS EG FOR CC GEOMETRY ###
   213         1         14.5     14.5      0.0          ntheta = ducc0.fft.good_size(lmax_unl + 2)
   214         1          0.5      0.5      0.0          nphihalf = ducc0.fft.good_size(lmax_unl + 1)
   215         1          0.4      0.4      0.0          nphi = 2 * nphihalf
   216         1          2.7      2.7      0.0          print(' ------------ Finished PARAMS -------------')
   217                                           
   218                                                   
   219                                                   ### SYNTHESIS CC GEOMETRY ###
   220         1          8.8      8.8      0.0          import cunusht
   221         1          4.2      4.2      0.0          geominfo_cc = ('cc',{'nphi':2*(lmax+1), 'ntheta':lmax+1})
   222                                                   # tcc = cunusht.get_transformer('ducc', 'SHT', 'CPU')(geominfo_cc)
   223         1   11755110.7    1e+07     62.1          tcc = cunusht.get_transformer('shtns', 'SHT', 'GPU')(geominfo_cc)
   224         1     230486.9 230486.9      1.2          map = tcc.synthesis(gclm, spin=0, lmax=lmax, mmax=mmax, nthreads=4).reshape(lmax+1,-1)
   225         1         36.2     36.2      0.0          print(' ------------ Finished synthesis on CC -------------')
   226                                           
   227                                                   ### DOUBLING ###
   228                                                   # %timeit say 80 ms for 2058x4096 on CPU, what about GPU?
   229         1         27.8     27.8      0.0          map_dfs = np.empty((2 * ntheta - 2, nphi), dtype=np.complex128 if spin == 0 else ctype[map.dtype])
   230         1          0.5      0.5      0.0          if spin == 0:
   231         1     119294.5 119294.5      0.6              map_dfs[:ntheta, :] = map[0]
   232                                                   else:
   233                                                       map_dfs[:ntheta, :].real = map[0]
   234                                                       map_dfs[:ntheta, :].imag = map[1]
   235         1        789.9    789.9      0.0          del map
   236         1     120687.3 120687.3      0.6          map_dfs[ntheta:, :nphihalf] = map_dfs[ntheta - 2:0:-1, nphihalf:]
   237         1      54500.7  54500.7      0.3          map_dfs[ntheta:, nphihalf:] = map_dfs[ntheta - 2:0:-1, :nphihalf]
   238         1          3.2      3.2      0.0          if (spin % 2) != 0:
   239                                                       map_dfs[ntheta:, :] *= -1
   240         1         26.4     26.4      0.0          print(' ------------ Finished doubling -------------')
   241                                           
   242                                           
   243                                                   ### GO TO FOURIER SPACE ###
   244                                                   # cufft interface gives me 11 ms as opposed to duccs 65 ms for 2058x4096
   245         1          1.0      1.0      0.0          if HAS_CUFFT:
   246         1          0.5      0.5      0.0              if spin == 0:
   247         1          4.6      4.6      0.0                  BATCH, NX = map_dfs.T.shape
   248         1        810.7    810.7      0.0                  data_o_gpu  = gpuarray.empty((BATCH,NX),dtype=np.complex64)
   249         1       6899.2   6899.2      0.0                  plan = cu_fft.Plan(map_dfs.shape, np.complex64, np.complex64)
   250         1     230490.7 230490.7      1.2                  data_t_gpu  = gpuarray.to_gpu(map_dfs)
   251         1         97.5     97.5      0.0                  cu_fft.ifft(data_t_gpu, data_t_gpu, plan)
   252         1     182036.5 182036.5      1.0                  map_dfs = data_o_gpu.get()
   253                                                           # data_o_gpu.free()
   254                                                       else:
   255                                                           assert 0, "implement if needed"
   256                                                   else:
   257                                                       if spin == 0:
   258                                                           tmp = np.empty(map_dfs.T.shape, dtype=np.complex128)
   259                                                           map_dfs = ducc0.fft.c2c(map_dfs.T, axes=(0, 1), inorm=2, nthreads=self.nthreads, out=tmp)
   260                                                           del tmp
   261                                                       else:
   262                                                           map_dfs = ducc0.fft.c2c(map_dfs, axes=(0, 1), inorm=2, nthreads=self.nthreads, out=map_dfs)
   263         1         30.8     30.8      0.0          print(' ------------ Finished c2c -------------')
   264                                           
   265                                           
   266                                                   ### NUFFT ###
   267         1          6.4      6.4      0.0          if self.planned: 
   268                                                       assert ptg is None
   269                                                       plan = self.make_plan(lmax_unl, spin)
   270                                                       values = plan.u2nu(grid=map_dfs, forward=False, verbosity=self.verbosity)
   271                                                       self.tim.add('planned u2nu')
   272                                                   else:
   273         1          0.2      0.2      0.0              ptg = None
   274         1          0.7      0.7      0.0              if ptg is None:
   275         1    2223869.2    2e+06     11.7                  synth_spin1_map = self._build_d1(dlm, lmax, mmax)
   276                                                           # TODO is this expensive? Can we port this to GPU?
   277         1    1035063.7    1e+06      5.5                  ptg = self._get_ptg(synth_spin1_map, mmax)
   278         1         29.5     29.5      0.0              self.tim.add('get ptg')
   279                                           
   280         1     176592.2 176592.2      0.9              map_shifted = np.fft.fftshift(map_dfs, axes=(0,1))
   281         1    2402864.6    2e+06     12.7              v_ = cufinufft.nufft2d2(x=cp.array(ptg[:,1][::-1]), y=cp.array(ptg[:,0]), data=cp.array(map_shifted.astype(np.complex128)))
   282         1     296999.8 296999.8      1.6              values = np.roll(np.real(v_.get()).reshape(lmax+1,-1), int(self.geom.nph[0]/2-1), axis=1)
   283         1         18.0     18.0      0.0              self.tim.add('u2nu')
   284         1         30.9     30.9      0.0          print(' ------------ Finished nuFFT -------------')
   285                                           
   286         1          1.8      1.8      0.0          if polrot * spin:
   287                                                       if self._cis:
   288                                                           cis = self._get_cischi()
   289                                                           for i in range(polrot * abs(spin)):
   290                                                               values *= cis
   291                                                           self.tim.add('polrot (cis)')
   292                                                       else:
   293                                                           if HAS_DUCCROTATE:
   294                                                               lensing_rotate(values, self._get_gamma(), spin, self.nthreads)
   295                                                               self.tim.add('polrot (ducc)')
   296                                                           else:
   297                                                               func = fremap.apply_inplace if values.dtype == np.complex128 else fremap.apply_inplacef
   298                                                               func(values, self._get_gamma(), spin, self.nthreads)
   299                                                               self.tim.add('polrot (fortran)')
   300         1          2.7      2.7      0.0          print(' ------------ returning result ------------')
   301         1      91901.2  91901.2      0.5          return values.real.flatten() if spin == 0 else values.view(rtype[values.dtype]).reshape((values.size, 2)).T

  0.85 seconds - /mnt/home/sbelkner/git/cunusht/cunusht/deflection/GPU_nufft_transformer.py:93 - _build_angles
 18.93 seconds - /mnt/home/sbelkner/git/cunusht/cunusht/deflection/GPU_nufft_transformer.py:191 - gclm2lenmap
