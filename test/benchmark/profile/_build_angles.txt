Timer unit: 1e-06 s

Total time: 6.07411 s
File: /mnt/home/sbelkner/git/cunusht/cunusht/deflection/GPU_nufft_transformer.py
Function: _build_angles at line 96

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    96                                               @profile
    97                                               def _build_angles(self, synth_spin1_map, lmax_dlm, mmax_dlm, fortran=True, calc_rotation=True, HAS_DUCCPOINTING=True):
    98                                                   """Builds deflected positions and angles
    99                                                       Returns (npix, 3) array with new tht, phi and -gamma
   100                                                   """
   101         1         11.7     11.7      0.0          fns = ['ptg'] + calc_rotation * ['gamma']
   102         1         86.3     86.3      0.0          if not np.all([self.cacher.is_cached(fn) for fn in fns]):
   103                                                       # Probably want to keep red, imd double precision for the calc?
   104         1          0.2      0.2      0.0              if HAS_DUCCPOINTING:
   105         1         23.5     23.5      0.0                  print('Calculating pointing angles using ducc0.misc.get_deflected_angles()')
   106                                                           # FIXME if shtns is used, we need to access SHTns info about geom.
   107         1          9.8      9.8      0.0                  tht, phi0, nph, ofs = self.geom.theta, self.geom.phi0, self.geom.nph, self.geom.ofs
   108         2     639440.5 319720.2     10.5                  tht_phip_gamma = get_deflected_angles(theta=tht, phi0=phi0, nphi=nph, ringstart=ofs, deflect=synth_spin1_map.T,
   109         1          0.4      0.4      0.0                                                          calc_rotation=calc_rotation, nthreads=self.nthreads)
   110         1          1.3      1.3      0.0                  if calc_rotation:
   111         1     312625.1 312625.1      5.1                      self.cacher.cache(fns[0], tht_phip_gamma[:, 0:2])
   112         1     138274.5 138274.5      2.3                      self.cacher.cache(fns[1], tht_phip_gamma[:, 2] if not self.single_prec else tht_phip_gamma[:, 2].astype(np.float32))
   113                                                           else:
   114                                                               self.cacher.cache(fns[0], tht_phip_gamma)
   115                                                           # return
   116         1         30.9     30.9      0.0              print('Calculating pointing angles using lenspyx')
   117         1        124.1    124.1      0.0              npix = self.geom.npix()
   118         1         20.0     20.0      0.0              thp_phip_gamma = np.empty((3, npix), dtype=float)  # (-1) gamma in last arguement
   119         1          0.3      0.3      0.0              startpix = 0
   120         1         73.7     73.7      0.0              assert np.all(self.geom.theta > 0.) and np.all(self.geom.theta < np.pi), 'fix this (cotangent below)'
   121         1          9.8      9.8      0.0              red, imd = synth_spin1_map
   122      4097       2397.7      0.6      0.0              for ir in np.argsort(self.geom.ofs): # We must follow the ordering of scarf position-space map
   123      4096     105852.0     25.8      1.7                  pixs = Geom.rings2pix(self.geom, [ir])
   124      4096       3221.7      0.8      0.1                  if pixs.size > 0:
   125      4096      75780.2     18.5      1.2                      t_red = red[pixs]
   126      4096      59262.5     14.5      1.0                      i_imd = imd[pixs]
   127      4096     441597.4    107.8      7.3                      phis = Geom.phis(self.geom, ir)[pixs - self.geom.ofs[ir]]
   128      4096       2918.7      0.7      0.0                      assert phis.size == pixs.size, (phis.size, pixs.size)
   129      4096      63814.3     15.6      1.1                      thts = self.geom.theta[ir] * np.ones(pixs.size)
   130      4096    1786607.8    436.2     29.4                      thtp_, phip_ = d2ang(t_red, i_imd, thts , phis, int(np.round(np.cos(self.geom.theta[ir]))))
   131      4096       7663.2      1.9      0.1                      sli = slice(startpix, startpix + len(pixs))
   132      4096      81067.5     19.8      1.3                      thp_phip_gamma[0, sli] = thtp_
   133      4096      71897.4     17.6      1.2                      thp_phip_gamma[1, sli] = phip_
   134      4096      41514.7     10.1      0.7                      cot = np.cos(self.geom.theta[ir]) / np.sin(self.geom.theta[ir])
   135      4096      88015.4     21.5      1.4                      d = np.sqrt(t_red ** 2 + i_imd ** 2)
   136      4096    1863198.2    454.9     30.7                      thp_phip_gamma[2, sli] = np.arctan2(i_imd, t_red ) - np.arctan2(i_imd, d * np.sin(d) * cot + t_red * np.cos(d))
   137      4096       4432.5      1.1      0.1                      startpix += len(pixs)
   138         1     185478.8 185478.8      3.1              self.cacher.cache(fns[0], thp_phip_gamma.T[:, 0:2])
   139         1          0.8      0.8      0.0              if calc_rotation:
   140         1      98654.4  98654.4      1.6                  self.cacher.cache(fns[1], thp_phip_gamma.T[:, 2] if not self.single_prec else thp_phip_gamma.T[:, 2].astype(np.float32) )
   141         1          1.7      1.7      0.0              assert startpix == npix, (startpix, npix)
   142         1          0.3      0.3      0.0              return

  6.07 seconds - /mnt/home/sbelkner/git/cunusht/cunusht/deflection/GPU_nufft_transformer.py:96 - _build_angles
